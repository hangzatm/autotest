# 注意点：  体检登记管理页面，不能默认取第一个，因为如果有多个人员在跑自动化的话，就会取错！！！！！！
# 注意点：  体检登记管理页面，不能默认取第一个，因为如果有多个人员在跑自动化的话，就会取错！！！！！！
# 注意点：  体检登记管理页面，不能默认取第一个，因为如果有多个人员在跑自动化的话，就会取错！！！！！！

# Generated by Selenium IDE
#   代码备注规范（可无视）：
#   1、三个#表示第一版（selenium自动生成的），两个#表示第二版（自己改了一次的）

# 踩坑：
# 1、【80%解决】【常见问题】在for i in list循环里找元素就会报错 ： element is not attached to the page document，解决方法：需要把i改为self.driver,然后后面的路径从类似.//td[2]/ 这种变为 //*[@id="divTarget"]/td[2] 全路径就行了，如果还不行，前面就再加个 time.sleep(2)
# 2、【已解决】开始很可能会点到“医生总检”，而不是“科室检查”
# 3（1）、【常见问题】科室检查的结果输入框，点击后，div元素结构会发生改变，导致点了某一元素后不能不能在同一元素上输入
# 3（2）、【常见问题】不同的指标项目，div元素结构还会发生不同的改变（例如“耳鼻咽喉科”的耳鼻喉科，跟“外科诊室”的“外科”结构改变还是不同的）：：解决方法：放在一个新的列表里区别处理，列表里存放的值为例如耳鼻喉科为 project-39。
#                    备注： ①一般的改变后的元素结构<table border="0" cellspacing="0" cellpadding="1"><tbody><tr><td><div class="textarea" contenteditable="true" style="min-height: 18px">结果值</div></td></tr></tbody></table>
#                           ②特殊的改变后的元素结构<table border="0" cellspacing="0" cellpadding="1"><tbody><tr><td><input type="text" class="datagrid-editable-input textbox-f" style="display: none;"><span class="textbox" style="width: 177px; height: 22px;"><input id="_easyui_textbox_input67" type="text" class="textbox-text validatebox-text" autocomplete="off" tabindex="" placeholder="" style="margin: 0px; padding-top: 0px; padding-bottom: 0px; height: 22px; line-height: 22px; width: 169px;"><input type="hidden" class="textbox-value" value="结果值"></span></td></tr></tbody></table>
# 4、多行文本输入框 textarea 会有个type="hidden"的兄弟节点，这个兄弟节点上会显示当前value值，但因为是隐藏的所以selenium找不到，实际上只要获取textarea的value值就可以找到了

# 最坑报错：各处随机出现 element is not attached to the page document，初步判断可能是页面局部刷新后selenium无法立即新页面下指定路径的元素（但浏览器上能查找到），暂定解决方法，加sleep

# 严重问题：
# 例如 耳鼻喉检 这个指标检验：在“鼻前庭”往前和往后，点击单选框，改变的元素结构竟然是不一样的，这个得问问老余 ，所以暂时先不检查“耳鼻咽喉科”

# 暂未考虑的问题：
# 1、年龄不符合，会有弹窗
# 2、性别不符合，会有弹窗
# 3、科室检查里的参考值为：“阴性-±”，那结果应该填啥
# 4、科室检查里的参考值为 >1.04  ，结果值无限大吗？
# 5、科室检查里的参考值为 ++－++++ ，是个什么东西，暂时设为未检

# 隐患：（搜索 隐患）
# 1、登记完的同时，有别人在登记，这样就导致收费的时候收的不是同一个。（会出现这种问题的情况：很多人同时在登记，也就是高并发，不过我这是自动化，不是测性能，应该可以忽略）
#   但上一步也会导致 获取的检查编号、科室不同，如果多个人在同时跑自动化，很可能会出现这种问题
# **2、（暂时不考虑，等后期优化）：存在有相同名字的科室，虽然我固定了哪个科室对应下拉列表的哪个序号，但是万一用户选了另外一个 科室，但我的序号还是之前那个，就凉凉了（所以最好先判断一下来到的科室是否正确，断言）

# 未考虑的因素：
# 1、科室检查——检查医生默认管理员

# 暂不实现的因素：
# 1、医生总检——结果值如果符合自动诊断的条件的，就会生成诊断内容，这个如果我每个都要判断一遍不现实

# 参数化：
# 需要参数化的地方：1、姓名或其他基本信息  2、体检套餐（包括不同科室，这个就需要写一份清单：哪个科室对应下拉列表第几个、且必须有权限（最好是权限全开的），另外体检套餐名也得是动态的）

# 可能需要修改的点：
# 1、科室检查，点击记录按钮，有的科室  默认检查结果会自动填写无异常，有的不会填写，单我还是先做成手动全无异常的：①值在参考值范围内 ②如果参考值是一个数值例如1.0，就写1.0 ③如果包含中文，就中文 ④参考值为空，值就为空

# 优化点 （搜索：优化点）

# 暂定逻辑 ：
# 1、科室检查——如果点击记录的时候，有默认值（一般为正常值），还是先clear掉，自己重新填写
# 2、医生总检——因为在科室检查中未检测全部
# 3、医生总检——只检查信息是否正确（点击记录按钮后直接保存，去“已总”里面核对信息）

# 还未做的部分：
# 1、科室检查的结果中有“评估”按钮，需要点进去评估
# 2、个人基本信息未核对
# 3、医生总检——> “未检”、“弃检”、“异常指标”的数量未核对
# 4、医生总检——> 检查项目列表 中的 “无”表示该项目无指标，需要去“体检指标设置”里核对 （可以在体检登记完成后去体检指标设置里查看。）
# 5、医生总检——> 无指标的科室，在“科室小结”中会直接显示“未见异常”，而不是“未检”，如果要证明这个科室无指标，需要去“体检指标设置”里核对 ，
#    还有综述也是这种情况。

# 要注意的逻辑：
# 1、科室检查 —— 添加 诊断 后保存，会提示是否重新生成小结
# 2、科室检查 —— 每个科室诊断的内容不能重复，会报错
# 3、（可忽略）科室检查 —— 每个诊断分类下最多显示20个诊断信息，假如每个科室选择2个，一旦要检测的科室超过10个，就要换页。还可能某个分类下的诊断信息行数不够，那就不添加诊断信息了

# 脚本执行最慢的地方：搜索顺序问题：例如科室检查的“已检”结果列表：排序方式为最新的在最下面一个，遍历花的时候较多

import random

import pytest
import time
import json

from selenium import webdriver
from selenium.common.exceptions import StaleElementReferenceException
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
# EC: 16种元素方法
from selenium.webdriver.support import expected_conditions as EC


#   该方法用来确认元素是否存在，如果存在返回flag=true，否则返回false
def ifElementExist(self, element):
    flag = True
    browser = self.driver
    try:
        # browser.find_element_by_css_selector(element)
        browser.find_element_by_xpath(element)
        return flag
    except:
        flag = False
        return flag


# 判断字符串中是否包含中文
def is_contain_chinese(check_str):
    """
  判断字符串中是否包含中文
  :param check_str: {str} 需要检测的字符串
  :return: {bool} 包含返回True， 不包含返回False
  """
    for ch in check_str:
        if u'\u4e00' <= ch <= u'\u9fff':
            return True
    return False


# 判断字符串是否为数字
def is_number(s):
    try:
        float(s)
        return True
    except ValueError:
        pass
    try:
        import unicodedata
        unicodedata.numeric(s)
        return True
    except (TypeError, ValueError):
        pass
    return False


# 登录
# @pytest.fixture(scope="function")
# def test_login(self):
#     print("开始登录")
#     # 设置隐式等待页面加载完成：防止页面未加载完出现差错
#     driver.implicitly_wait(10)
#     driver.get("http://101.132.163.3:7996/")
#     driver.set_window_size(1936, 1056)
#     driver.find_element(By.ID, "_easyui_textbox_input1").click()
#     driver.find_element(By.ID, "_easyui_textbox_input1").send_keys("999")
#     driver.find_element(By.ID, "_easyui_textbox_input2").click()
#     driver.find_element(By.ID, "_easyui_textbox_input2").send_keys("1")
#     # 优化点 ：输入完密码马上点登录无法登录
#     time.sleep(1)
#     driver.find_element(By.ID, "btnLogin").click()
#     print("结束登录")
#     driver.find_element(By.CSS_SELECTOR, ".panel:nth-child(2) .panel-title").click()

# data_person_name = ["周业钜", "周业钜2", "周业钜3"]
# 科室对应的下拉框序号  
# 参数化
data_ks_list = {'外科诊室': 26, '眼科': 25, '耳鼻咽喉科': 1,'口腔科':23}
# 不同的指标项目，div元素结构还会发生不同的改变（例如“耳鼻咽喉科”的耳鼻喉科，跟“外科诊室”的“外科”结构改变还是不同的）：：解决方法：放在一个新的列表里区别处理
# 存放每一个特殊的指标标题名，例如耳鼻喉科为 project-39，后期慢慢添加
dif_project_list = {'耳鼻咽喉科-耳鼻喉科': 39}
#保存当前人员信息
data_person = {}


class Test1():
    def setup_method(self, method):
        self.driver = webdriver.Chrome()
        self.vars = {}

    def teardown_method(self, method):
        pass
        # driver.quit()

    def iframe_search(self, path):
        framedict = {}
        for child_frame in self.driver.find_elements_by_tag_name('frame'):
            child_frame_name = child_frame.get_attribute('name')
            framedict[child_frame_name] = {'framepath': path, 'children': {}}
            xpath = '//frame[@name="{}"]'.format(child_frame_name)
            self.driver.switch_to.frame(self.driver.find_element_by_xpath(xpath))
            framedict[child_frame_name]['children'] = self.frame_search(
                framedict[child_frame_name]['framepath'] + [child_frame_name])
            """
        do
        something
        involving
        this
        child_frame
        """
            self.driver.switch_to.default_content()
            if len(framedict[child_frame_name]['framepath']) > 0:
                for parent in framedict[child_frame_name]['framepath']:
                    parent_xpath = '//frame[@name="{}"]'.format(parent)
                    self.driver.switch_to.frame(self.driver.find_element_by_xpath(parent_xpath))
        return framedict

    # 登录+体检登记
    # @pytest.mark.parametrize('person_name', data_person_name)
    # def test_tjdj(self,person_name):
    def test_tjdj(self):
        driver = self.driver
        print("开始登录")
        # 设置隐式等待页面加载完成：防止页面未加载完出现差错
        driver.implicitly_wait(10)
        # 优化点  网站可能会打不开
        driver.get("http://101.132.163.3:7996/")
        driver.set_window_size(1936, 1056)
        driver.find_element(By.ID, "_easyui_textbox_input1").click()
        driver.find_element(By.ID, "_easyui_textbox_input1").send_keys("999")
        driver.find_element(By.ID, "_easyui_textbox_input2").click()
        driver.find_element(By.ID, "_easyui_textbox_input2").send_keys("1")
        # 优化点 ：输入完密码马上点登录无法登录
        time.sleep(1)
        driver.find_element(By.ID, "btnLogin").click()
        print("结束登录")
        print("开始体检登记流程")
        # 进入体检登记界面
        # 先点击“日报工作”菜单
        driver.find_element(By.CSS_SELECTOR, ".panel:nth-child(2) .panel-title").click()  # selenium
        # driver.find_element(By.CSS_SELECTOR, "#\\_easyui_tree_12 > .tree-title").click()  #selenium
        # 优化：等待下拉列表出现，否则报错element not interactable,给1秒钟还是会出问题
        time.sleep(2)  # 这个强制等待很可能无法省略了
        # print("点击的是："+driver.find_element_by_xpath('//div[@id="_easyui_tree_12"]/./span[2]').text)
        # 再点击“体检登记界面”
        # for _ in range(3):
        #     try:
        #         WebDriverWait(driver, 10).until(
        #             EC.element_to_be_clickable((By.XPATH, '//div[@id="_easyui_tree_12"]/span[3]'))
        #         )
        #     except Exception:
        #         time.sleep(1)
        #         print("再等一秒看看能不能点击体检登记")

        WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.XPATH, '//div[@id="_easyui_tree_12"]/span[3]'))
        )
        assert driver.find_element(By.XPATH, '//*[@id="_easyui_tree_12"]/span[3]').text == "体检登记"  # 如果点击的不是科室检查就报错
        driver.find_element(By.XPATH, '//*[@id="_easyui_tree_12"]/span[3]').click()
        # driver.find_element_by_xpath('//div[@id="_easyui_tree_12"]/./span[3]').click()
        driver.switch_to.frame(0)
        # driver.find_element(By.ID, "_easyui_textbox_input40").click()   #selenium
        # driver.find_element(By.ID, "_easyui_textbox_input40").send_keys("zyj")  #selenium
        driver.find_element_by_xpath('//input[@id="_easyui_textbox_input40"]').click()
        # 优化点：不同的姓名需要参数化；还有别的参数可以填写
        # driver.find_element_by_xpath('//input[@id="_easyui_textbox_input40"]').send_keys("周业钜zdh")
        # 选择出生日期
        ##打开日期选择
        # 最好还是输入身份证号码
        driver.find_element_by_xpath('//input[@id="_easyui_textbox_input43"]').click()
        # 输入身份证会从哪里自动获取一个详细的用户信息？
        driver.find_element_by_xpath('//input[@id="_easyui_textbox_input43"]').send_keys("330103199808020015")
        driver.find_element_by_xpath('//input[@id="_easyui_textbox_input43"]').send_keys(Keys.ENTER)
        data_person['姓名']=driver.find_element_by_xpath('//*[@id="divBaseInfo1"]/div[2]/div/table/tbody/tr[2]/td[2]/span/input[1]').get_attribute("value")
        data_person['性别']=driver.find_element_by_xpath('//*[@id="divBaseInfo1"]/div[2]/div/table/tbody/tr[3]/td[2]/span/input[1]').get_attribute("value")
        data_person['年龄']=driver.find_element_by_xpath('//*[@id="divBaseInfo1"]/div[2]/div/table/tbody/tr[3]/td[3]/span[5]/input[1]').get_attribute("value")
        data_person['婚姻']=driver.find_element_by_xpath('//*[@id="divBaseInfo1"]/div[2]/div/table/tbody/tr[3]/td[3]/span[3]/input[1]').get_attribute("value")
        data_person['单位']=driver.find_element_by_xpath('//*[@id="divBaseInfo1"]/div[2]/div/table/tbody/tr[4]/td[2]/span[1]/input[1]').get_attribute("value")
        data_person['部门']=driver.find_element_by_xpath('//*[@id="divBaseInfo1"]/div[2]/div/table/tbody/tr[4]/td[2]/span[2]/input[1]').get_attribute("value")
        data_person['体检类型']=driver.find_element_by_xpath('//*[@id="divBaseInfo1"]/div[2]/div/table/tbody/tr[1]/td[5]/span/input[1]').get_attribute("value")
        #参数化
        data_person['套餐名称'] = driver.find_element(By.XPATH, '//*[@id="datagrid-row-r3-2-0"]/td[1]').text
        print("收集的人员信息为："+str(data_person))

        ## driver.find_element(By.CSS_SELECTOR, ".datebox:nth-child(3) .textbox-icon").click()
        ### 优化：不同的日期需要参数化
        ### driver.find_element(By.LINK_TEXT, "今天").click()  #selenium
        ## driver.find_element_by_xpath('//*[@id="bodyLayout"]/div[22]/div/div[2]/table/tbody/tr/td[1]/a').click()
        # 优化点：不同的套餐列表需要参数化，还有“项目列表”、“附加费用”,且套餐该怎么定位
        # driver.find_element(By.CSS_SELECTOR, "#datagrid-row-r3-2-1 .datagrid-cell-c3-GroupPrice").click()
        # element = driver.find_element(By.CSS_SELECTOR, "#datagrid-row-r3-2-1 .datagrid-cell-c3-GroupPrice")
        element = driver.find_element(By.CSS_SELECTOR, "#datagrid-row-r3-2-0 .datagrid-cell-c3-GroupPrice")
        actions = ActionChains(driver)
        actions.double_click(element).perform()

        # driver.find_element(By.XPATH, '//*[@id="bodyLayout"]/div[47]/div[3]/a[1]').click() #年龄不符合，点确定

        driver.find_element(By.CSS_SELECTOR, "#btnChargeSave .l-btn-text").click()

        # driver.find_element(By.XPATH, '//*[@id="bodyLayout"]/div[47]/div[3]/a[1]').click()  # 年龄不符合，再次点确定

        print("结束体检登记流程")

        print("开始收费流程（体检登记管理界面）")
        driver.switch_to.default_content()
        # 进入体检登记管理界面
        driver.find_element(By.CSS_SELECTOR, "#\\_easyui_tree_25 > .tree-title").click()
        driver.switch_to.frame(1)
        # driver.find_element(By.CSS_SELECTOR, "#\\_easyui_tree_25 > .tree-title").click()
        # driver.find_element_by_xpath('//*[@id="_easyui_tree_25"]/span[3]').click()
        # 搜索第一个姓名为“周业钜”的数据（不能搜索第一条数据，防止出现别的地方突然新增了一条数据的情况）
        # 用 find_element_by_link_text 方式定位，标签必须是<a></a>的元素，才能成功。
        # 点击搜索按钮（默认搜索当天的），更新出最新信息
        print("点击搜索按钮")
        driver.find_element(By.CSS_SELECTOR, "#btnSearch .l-btn-text").click()
        time.sleep(1)

        # 获取新登记人员的检查编号
        checkNo = driver.find_element_by_xpath('//*[@id="datagrid-row-r3-2-0"]/td[4]/div').text
        # 尝试替换成显示等待
        # checkNo = WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
        #     (By.XPATH, '//*[@id="datagrid-row-r3-2-0"]/td[4]/div'))).text

        print("新登记人员的检查编号是：" + checkNo)
        # 获取新登记人员的科室
        # 遍历
        # css获取li组
        ksList = []  # 科室列表
        checkProjectNameList = []  # 要检验的项目名称列表
        tds = driver.find_elements_by_xpath(
            '//*[@id="divMainCenter"]/div[4]/div/div/div/div[2]/div[2]/div[2]/table/tbody/tr')
        for index, i in enumerate(tds):
            checkProjectName = driver.find_element_by_xpath(
                '//*[@id="divMainCenter"]/div[4]/div/div/div/div[2]/div[2]/div[2]/table/tbody/tr[' + str(
                    index + 1) + ']/td[2]/div').text  # 每一个检验项目名称
            checkProjectNameList.append(checkProjectName)
            # print(i.find_element_by_xpath(".//td[8]/div").tag_name)
            # 【报错】 ：element is not attached to the page document
            # ksName = i.find_element_by_xpath(".//td[8]/div").text  # 每一个科室名
            ksName = driver.find_element_by_xpath(
                '//*[@id="divMainCenter"]/div[4]/div/div/div/div[2]/div[2]/div[2]/table/tbody/tr[' + str(
                    index + 1) + ']/td[8]/div').text  # 每一个科室名
            # print(ksName)
            ksList.append(ksName)
        print("要检验的项目名称列表为：" + str(checkProjectNameList))
        # 科室列表去重且不改变顺序
        print("去重前的科室列表为：" + str(ksList))
        ksList2 = list(set(ksList))
        ksList2.sort(key=ksList.index)
        print("去重后的科室列表为：" + str(ksList2))

        # 点击收费
        # 1、登记完的同时，有别人在登记，这样就导致收费的时候收的不是同一个。（会出现这种问题的情况：很多人同时在登记，也就是高并发，不过我这是自动化，不是测性能，应该可以忽略）
        # driver.find_element_by_xpath("//*[text()='周业钜']]").click()
        # 算了直接点收费了
        print(
            "点击收费按钮（前提是收费按钮存在，得开权限）")  # 开启收费按钮方法：权限设置找到PEIS_CHARGE_REG，人员私有行为权限里添加999管理员，系统参数设置  PEIS_SHOW_CHARGE_BTN 设置 Y（显示收费按钮）
        # driver.find_element(By.CSS_SELECTOR, ".icon-charge").click()
        # 尝试替换成显示等待
        WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.CSS_SELECTOR, '.icon-charge'))
        ).click()

        time.sleep(1)
        # driver.switch_to.default_content()
        print("结束收费流程（体检登记管理界面）")
        # 打开科室检查
        print("开始科室检查")
        driver.switch_to.default_content()
        # 进入体检登记管理界面
        # 点击菜单栏中的“科室检查”
        # driver.find_element(By.ID, "_easyui_tree_13").click()
        # driver.find_element(By.XPATH, "#\\_easyui_tree_13 > .tree-title").click()
        driver.find_element(By.XPATH, '//*[@id="_easyui_tree_13"]/span[3]').click()
        # 此时为第二个iframe框
        driver.switch_to.frame(2)
        # 点击“检查科室”右边的下拉图标
        # driver.find_element_by_xpath('//*[@id="divMainCenter"]/div[1]/div/div/span[2]/span/a').click()
        # 选择不同的科室
        # 注意：要选择不同的科室去检查，初步逻辑：因为下拉列表是动态id，暂定按照序号选择科室（例如外科诊室是第26个）
        # time.sleep(1)  # 这个强制等待是否可以删除？
        #
        ksNum = 0  # 检查科室数量
        ksList3 = {}  # 保存最多两个科室（不到两个科室也可）对应的下拉框序号
        briefSummaryList = {}  # 保存两个科室的科室总结
        zdAllList = []  # 保存所有科室的诊断信息
        for i in ksList2:
            for k, v in data_ks_list.items():
                if ksNum < 2 and i == k:  # 设置最多只检查两个科室
                    print("科室：" + str(k) + "对应的序号为：" + str(v))
                    ksList3[str(k)] = str(v)
                    ksNum = ksNum + 1
        print("生成的要检查的科室下拉框序号字典为：" + str(ksList3))

        diagnoseIndex = 1  # 为了让每个科室的诊断内容不重复，设置一个变量
        # 开始对每个科室进行检查,
        for _ks, v in ksList3.items():
            # 先选到对应科室
            print("当前准备检验的科室为：" + str(_ks))
            print("加载中...")  # 遍历需要时间，而且数据一多就会花很长时间
            # 点击“检查科室”右边的下拉图标
            driver.find_element_by_xpath('//*[@id="divMainCenter"]/div[1]/div/div/span[2]/span/a').click()
            driver.find_element_by_xpath('//*[@id="bodyLayout"]/div[56]/div/div[' + v + ']').click()

            # time.sleep(1) # 这个等待看能不能删除，很脱时间

            driver.find_element(By.CSS_SELECTOR, ".datebox:nth-child(4) .textbox-icon").click()
            driver.find_element(By.LINK_TEXT, "今天").click()
            driver.find_element(By.CSS_SELECTOR, "#btnSearch .l-btn-text").click()

            # 进入“未检”界面
            print("准备进入“未检”界面")
            driver.find_element_by_xpath('//*[@id="formSearch"]/div[18]/div/label[2]/input').click()
            print("当前人员检查编号为：" + checkNo)
            time.sleep(0.5)  # 需要停一秒等待搜索结果加载完成，看看能不能优化

            # time.sleep(2)
            # 然后找对应检查编号的数据
            dataList = driver.find_elements_by_xpath(
                '//*[@id="layoutPersonList"]/div[2]/div/div/div/div[2]/div[2]/div[2]/table/tbody/tr')

            # 尝试替换成显示等待
            # dataList = WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
            #     (By.XPATH, '//*[@id="layoutPersonList"]/div[2]/div/div/div/div[2]/div[2]/div[2]/table/tbody/tr')))

            # 强制等五秒好像太慢了，不等待的话会报错  element is not attached to the page document
            # 优化点：改为显示等待元素加入到dom之后，再下一步操作 （用presence_of_element_located无效），改用显示等待+EC判断是否可点击
            # time.sleep(5)
            # 科室检查——遍历搜索出来的一行行数据，找出刚刚登记的那条
            for index, data in enumerate(dataList):
                # 很好的显示等待方法 ↓
                # WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                #   (By.XPATH, '//*[@id="layoutPersonList"]/div[2]/div/div/div/div[2]/div[2]/div[2]/table/tbody')))
                # WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                #     (By.XPATH, '//*[@id="layoutPersonList"]/div[2]/div/div/div/div[2]/div[2]/div[2]/table/tbody/tr')))
                # element_to_be_clickable
                # 从搜索结果中找刚刚登记的那条
                for _ in range(3):
                    try:
                        WebDriverWait(driver, 10).until(
                            EC.visibility_of_element_located((By.XPATH,
                                                              '//*[@id="layoutPersonList"]/div[2]/div/div/div/div[2]/div[2]/div[2]/table/tbody/tr'))
                        )
                    except Exception:
                        time.sleep(1)
                        print("再等一秒看看能不能找到结果")
                # 【报错】 ：element is not attached to the page document，修改方案：data改为driver
                # time.sleep(1)  # 不加可能会报错 ↑
                # ksCheckNo = data.find_element_by_xpath('.//td[4]/div[1]').text  # 科室检查通过查询查出来的检查编号
                # ksCheckNo = driver.find_element_by_xpath(
                #     '//*[@id="layoutPersonList"]/div[2]/div/div/div/div[2]/div[2]/div[2]/table/tbody/tr[' + str(
                #         index + 1) + ']/td[4]/div[1]').text  # 科室检查通过查询查出来的检查编号
                # 尝试替换成显示等待
                ksCheckNo = WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                    (By.XPATH, '//*[@id="layoutPersonList"]/div[2]/div/div/div/div[2]/div[2]/div[2]/table/tbody/tr[' + str(
                        index + 1) + ']/td[4]/div[1]'))).text

                print("正在遍历的检查编号是：" + str(ksCheckNo))
                if checkNo == ksCheckNo:  # 查找刚刚登记的用户对应检查编号的数据行
                    print("找到了")
                    # 【报错】 ：element is not attached to the page document，修改方案：data改为driver
                    # data.find_element_by_xpath('.//td[4]/div[1]').click()
                    # 点击刚刚登记的体检数据
                    driver.find_element_by_xpath(
                        '//*[@id="layoutPersonList"]/div[2]/div/div/div/div[2]/div[2]/div[2]/table/tbody/tr[' + str(
                            index + 1) + ']/td[4]/div[1]').click()
                    # 点击“记录”按钮，开始科室检查 (前提是已收费)
                    driver.find_element(By.CSS_SELECTOR, "#btnEdit .l-btn-text").click()
                    # self.driver.find_element(By.CSS_SELECTOR, ".datagrid-row-over > .datagrid-cell > div").click()
                    # 设置检验结果值 （暂定全为正常）
                    # 结果规则： ①值在参考值范围内，参考范围的写法目前我看到三种： 0-1  0－1  0--1
                    #          ②如果参考值是一个数值例如1.0，就写1.0
                    #          ③如果参考值包含中文，结果就中文  :
                    #          ④参考值为空，值就为空
                    #          ⑤ <5.20  >1.04，也算参考范围
                    #          ⑥ 特殊情况：评估按钮，需要点击进去，然后评估
                    # 注意：css是这样设计的 <div><div></div><table></table><div></div><table></table></div>  ，直接改每个table里的值就行了——>遍历table
                    tbList = driver.find_elements_by_xpath(
                        '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table')  # 多个指标填写区域栏
                    print("获取的table数量是：" + str(len(tbList)))
                    for index, tb in enumerate(tbList):
                        time.sleep(1)  # 不加很可能会报错 element is not attached to the page document
                        # 当前table标签的上一个div兄弟节点（为了获取当前指标的总指标标题名的project-${id}）
                        projectId = driver.find_element_by_xpath(
                            '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                index + 1) + ']/preceding-sibling::div[1]/span[2]/span[1]').get_attribute("class")[8:]
                        print("指标project-id：" + projectId)

                        trList = driver.find_elements_by_xpath(
                            '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(index + 1) + ']/tbody/tr')
                        print("正在操作当前指标总行数是：" + str(len(trList)))
                        # WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.XPATH,'//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(index + 1) + ']')))
                        WebDriverWait(driver, 10).until(
                            EC.visibility_of_element_located((By.XPATH,
                                                              '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                                                  index + 1) + ']'))
                        )
                        # 遍历每一行指标
                        for index2, tr in enumerate(trList):
                            # print("当前记录的指标标题栏模块名是：" + str(tr))
                            # refValue = tr.find_element_by_xpath('.//td[4]/div[1]').text  # 每一行指标的参考值
                            # print('xpath路径为：' + '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                            #     index2 + 1) + ']/tbody/tr[' + str(index2 + 1) + ']/td[4]/div[1]')
                            # driver.switch_to.frame(1)

                            # refValue = tr.find_element_by_xpath('//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(index + 1) + '+1]/tbody/tr[' + str(index2 + 1) + ']/td[4]/div[1]').text  # 每一行指标的参考值

                            time.sleep(1)  # 这个等待无法删除，删除报致命错误 ：element is not attached to the page document
                            #
                            refValue = driver.find_element_by_xpath(
                                '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                    index + 1) + ']/tbody/tr[' + str(index2 + 1) + ']/td[4]/div[1]').text  # 每一行指标的参考值

                            # for _ in range(3):
                            #     try:
                            #       refValue = tr.find_element_by_xpath('.//td[4]/div[1]').text  # 每一行指标的参考值
                            #     except Exception:
                            #       print("再找一次每一行指标的参考值")

                            # refName = tr.find_element_by_xpath('//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[index+1]/tbody/tr[index2]/td[1]/div[1]').text  # 当前行指标名
                            time.sleep(1)
                            # 【报错】 ：element is not attached to the page document
                            refName = driver.find_element_by_xpath(
                                '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                    index + 1) + ']/tbody/tr[' + str(index2 + 1) + ']/td[1]/div[1]').text  # 当前行指标名
                            # for _ in range(3):
                            #     try:
                            #       refName = tr.find_element_by_xpath('.//td[1]/div[1]').text  # 当前行指标名
                            #     except Exception:
                            #         print("再找一次当前行指标名")
                            # 特殊指标->特殊元素格式->特殊处理
                            specialExist = 0
                            for k, v in dif_project_list.items():
                                # print("v：" + str(v))
                                # print("projectId：" + str(projectId))
                                if int(projectId) == int(v):
                                    specialExist = 1
                            if not refValue.strip():  # 如果为空，就不填 （隐患：可能会出现虽然参考值为空，但点击记录的时候，结果可能会自动生成值的情况）
                                pass
                            elif is_contain_chinese(refValue) or is_number(refValue):  # 如果包含中文 或者是个数字，例如 1.0
                                print("指标：【" + refName + "】的结果值为：" + refValue)
                                # tr.find_element_by_xpath('.//td[2]/div[1]/div[1]').send_keys(refValue)  # 输入结果值
                                # tr.find_element_by_xpath('//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[index+1]/tbody/tr[index2]/td[2]/div[1]/div[1]').send_keys(refValue)  # 输入结果值
                                # driver.find_element_by_xpath(
                                #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                #         index + 1) + ']/tbody/tr[' + str(index2 + 1) + ']/td[2]/div/div').click()
                                #尝试替换成显示等待
                                WebDriverWait(driver, 15).until(EC.element_to_be_clickable(
                                      (By.XPATH,  '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                        index + 1) + ']/tbody/tr[' + str(index2 + 1) + ']/td[2]/div/div'))).click()

                                # print("specialExist:" + str(specialExist))
                                # time.sleep(1)
                                # print('xpath为：'+'//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                #         index + 1) + ']/tbody/tr[' + str(index2 + 1) + ']/td[2]/div')
                                # 点击单元格，元素结构会发生变化， 所有xpath路径要发生改变
                                # 先清空，再填入数据，因为点击记录按钮的时候可能会自动填入数据
                                if specialExist == 1:
                                    time.sleep(0.5)  # 需要加，否则报错找不到元素
                                    # driver.find_element_by_xpath(
                                    #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                    #         index + 1) + ']/tbody/tr[' + str(
                                    #         index2 + 1) + ']/td[2]/div/table/tbody/tr/td/span/input[1]').clear()
                                    # 尝试替换成显示等待
                                    WebDriverWait(driver, 15).until(EC.element_to_be_clickable(
                                        (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                            index + 1) + ']/tbody/tr[' + str(
                                            index2 + 1) + ']/td[2]/div/table/tbody/tr/td/span/input[1]'))).clear()
                                else:
                                    time.sleep(1)  # 需要加，否则报错找不到元素
                                    # driver.find_element_by_xpath(
                                    #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                    #         index + 1) + ']/tbody/tr[' + str(
                                    #         index2 + 1) + ']/td[2]/div/table/tbody/tr/td/div').clear()
                                    # 尝试替换成显示等待
                                    WebDriverWait(driver, 15).until(EC.element_to_be_clickable(
                                        (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                            index + 1) + ']/tbody/tr[' + str(
                                            index2 + 1) + ']/td[2]/div/table/tbody/tr/td/div'))).clear()
                                # driver.find_element_by_xpath(
                                #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                #         index + 1) + ']/tbody/tr[' + str(index2 + 1) + ']/td[2]/div[1]/div[1]').click()
                                # 尝试替换成显示等待
                                WebDriverWait(driver, 15).until(EC.element_to_be_clickable(
                                     (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                        index + 1) + ']/tbody/tr[' + str(index2 + 1) + ']/td[2]/div[1]/div[1]'))).click()
                                if specialExist == 1:
                                    # driver.find_element_by_xpath(
                                    #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                    #         index + 1) + ']/tbody/tr[' + str(
                                    #         index2 + 1) + ']/td[2]/div/table/tbody/tr/td/span/input[1]').send_keys(
                                    #     refValue)  # 输入结果值
                                    # 尝试替换成显示等待
                                    WebDriverWait(driver, 15).until(EC.element_to_be_clickable(
                                        (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                            index + 1) + ']/tbody/tr[' + str(
                                            index2 + 1) + ']/td[2]/div/table/tbody/tr/td/span/input[1]'))).send_keys(
                                        refValue)  # 输入结果值
                                else:
                                    # driver.find_element_by_xpath(
                                    #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                    #         index + 1) + ']/tbody/tr[' + str(
                                    #         index2 + 1) + ']/td[2]/div/table/tbody/tr/td/div').send_keys(
                                    #     refValue)  # 输入结果值
                                    # 尝试替换成显示等待
                                    WebDriverWait(driver, 15).until(EC.element_to_be_clickable(
                                        (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                            index + 1) + ']/tbody/tr[' + str(
                                            index2 + 1) + ']/td[2]/div/table/tbody/tr/td/div'))).send_keys(
                                        refValue)  # 输入结果值
                            elif "--" in refValue:  # 0.00--1.60
                                splitList = refValue.split("--")
                                # 断言：判断是否为数字
                                assert (is_number(splitList[0]) and is_number(splitList[1]))
                                print("分离'--'出来的参考值最低值为：" + str(splitList[0]).strip() + "，最高值为：" + str(
                                    splitList[1]).strip())
                                # 随机取一个正常数值
                                normalNum = int(random.uniform(float(splitList[0]), float(splitList[1])) * 100) / 100
                                # tr.find_element_by_xpath('.//td[2]/div[1]/div[1]').send_keys(normalNum)
                                # driver.find_element_by_xpath(
                                #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                #         index + 1) + ']/tbody/tr[' + str(index2 + 1) + ']/td[2]/div[1]/div[1]').click()
                                # 尝试替换成显示等待
                                WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                                    (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                        index + 1) + ']/tbody/tr[' + str(index2 + 1) + ']/td[2]/div[1]/div[1]'))).click()
                                # time.sleep(0.5)  # 需要加，否则可能会报错 ： element is not attached to the page document
                                if specialExist == 1:
                                    # driver.find_element_by_xpath(
                                    #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                    #         index + 1) + ']/tbody/tr[' + str(
                                    #         index2 + 1) + ']/td[2]/div/table/tbody/tr/td/span/input[1]').clear()
                                    # 尝试替换成显示等待
                                    WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                                        (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                            index + 1) + ']/tbody/tr[' + str(
                                            index2 + 1) + ']/td[2]/div/table/tbody/tr/td/span/input[1]'))).clear()
                                else:
                                    # driver.find_element_by_xpath(
                                    #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                    #         index + 1) + ']/tbody/tr[' + str(
                                    #         index2 + 1) + ']/td[2]/div/table/tbody/tr/td/div').clear()
                                    # 尝试替换成显示等待
                                    WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                                        (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                            index + 1) + ']/tbody/tr[' + str(
                                            index2 + 1) + ']/td[2]/div/table/tbody/tr/td/div'))).clear()
                                # driver.find_element_by_xpath(
                                #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                #         index + 1) + ']/tbody/tr[' + str(index2 + 1) + ']/td[2]/div[1]/div[1]').click()
                                # 尝试替换成显示等待
                                WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                                    (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                        index + 1) + ']/tbody/tr[' + str(index2 + 1) + ']/td[2]/div[1]/div[1]'))).click()
                                # time.sleep(0.5)  # 需要加，否则可能会报错 ： element is not attached to the page document
                                if specialExist == 1:
                                    # driver.find_element_by_xpath(
                                    #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                    #         index + 1) + ']/tbody/tr[' + str(
                                    #         index2 + 1) + ']/td[2]/div/table/tbody/tr/td/span/input[1]').send_keys(
                                    #     str(normalNum))  # 输入结果值
                                    # 尝试替换成显示等待
                                    WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                                        (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                            index + 1) + ']/tbody/tr[' + str(
                                            index2 + 1) + ']/td[2]/div/table/tbody/tr/td/span/input[1]'))).send_keys(
                                        str(normalNum))  # 输入结果值
                                else:
                                    # driver.find_element_by_xpath(
                                    #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                    #         index + 1) + ']/tbody/tr[' + str(
                                    #         index2 + 1) + ']/td[2]/div/table/tbody/tr/td/div').send_keys(
                                    #     str(normalNum))  # 输入结果值
                                    # 尝试替换成显示等待
                                    WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                                        (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                            index + 1) + ']/tbody/tr[' + str(
                                            index2 + 1) + ']/td[2]/div/table/tbody/tr/td/div'))).send_keys(
                                        str(normalNum))  # 输入结果值
                            elif "－" in refValue:  # 0－28.0
                                splitList = refValue.split("－")
                                # 断言：判断是否为数字
                                assert (is_number(splitList[0]) and is_number(splitList[1]))
                                print("分离'－'出来的参考值最低值为：" + str(splitList[0]).strip() + "，最高值为：" + str(
                                    splitList[1]).strip())
                                # 随机取一个正常数值
                                normalNum = int(random.uniform(float(splitList[0]), float(splitList[1])) * 100) / 100
                                # tr.find_element_by_xpath('.//td[2]/div[1]/div[1]').send_keys(normalNum)
                                # driver.find_element_by_xpath(
                                #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                #         index + 1) + ']/tbody/tr[' + str(index2 + 1) + ']/td[2]/div[1]/div[1]').click()
                                # time.sleep(0.5)  # 需要加，否则可能会报错 ： element is not attached to the page document
                                # 尝试替换成显示等待
                                WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                                    (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                        index + 1) + ']/tbody/tr[' + str(index2 + 1) + ']/td[2]/div[1]/div[1]'))).click()
                                if specialExist == 1:
                                    # driver.find_element_by_xpath(
                                    #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                    #         index + 1) + ']/tbody/tr[' + str(
                                    #         index2 + 1) + ']/td[2]/div/table/tbody/tr/td/span/input[1]').clear()
                                    # 尝试替换成显示等待
                                    WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                                        (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                            index + 1) + ']/tbody/tr[' + str(
                                            index2 + 1) + ']/td[2]/div/table/tbody/tr/td/span/input[1]'))).clear()
                                else:
                                    # driver.find_element_by_xpath(
                                    #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                    #         index + 1) + ']/tbody/tr[' + str(
                                    #         index2 + 1) + ']/td[2]/div/table/tbody/tr/td/div').clear()
                                    # 尝试替换成显示等待
                                    WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                                        (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                            index + 1) + ']/tbody/tr[' + str(
                                            index2 + 1) + ']/td[2]/div/table/tbody/tr/td/div'))).clear()
                                # driver.find_element_by_xpath(
                                #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                #         index + 1) + ']/tbody/tr[' + str(index2 + 1) + ']/td[2]/div[1]/div[1]').click()
                                # 尝试替换成显示等待
                                WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                                    (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                        index + 1) + ']/tbody/tr[' + str(index2 + 1) + ']/td[2]/div[1]/div[1]'))).click()
                                time.sleep(0.5)  # 需要加，否则可能会报错 ： element is not attached to the page document
                                if specialExist == 1:
                                    # driver.find_element_by_xpath(
                                    #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                    #         index + 1) + ']/tbody/tr[' + str(
                                    #         index2 + 1) + ']/td[2]/div/table/tbody/tr/td/span/input[1]').send_keys(
                                    #     str(normalNum))  # 输入结果值
                                    # 尝试替换成显示等待
                                    WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                                        (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                            index + 1) + ']/tbody/tr[' + str(
                                            index2 + 1) + ']/td[2]/div/table/tbody/tr/td/span/input[1]'))).send_keys(
                                        str(normalNum))  # 输入结果值
                                else:
                                    # driver.find_element_by_xpath(
                                    #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                    #         index + 1) + ']/tbody/tr[' + str(
                                    #         index2 + 1) + ']/td[2]/div/table/tbody/tr/td/div').send_keys(
                                    #     str(normalNum))  # 输入结果值
                                    # 尝试替换成显示等待
                                    WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                                        (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                            index + 1) + ']/tbody/tr[' + str(
                                            index2 + 1) + ']/td[2]/div/table/tbody/tr/td/div'))).send_keys(
                                        str(normalNum))  # 输入结果值

                            elif "-" in refValue:  # 0-1
                                splitList = refValue.split("-")
                                # 断言：判断是否为数字
                                assert (is_number(splitList[0]) and is_number(splitList[1]))
                                print("分离'-'出来的参考值最低值为：" + str(splitList[0]).strip() + "，最高值为：" + str(
                                    splitList[1]).strip())
                                # 随机取一个正常数值
                                normalNum = int(random.uniform(float(splitList[0]), float(splitList[1])) * 100) / 100
                                # tr.find_element_by_xpath('.//td[2]/div[1]/div[1]').send_keys(normalNum)
                                # driver.find_element_by_xpath(
                                #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                #         index + 1) + ']/tbody/tr[' + str(index2 + 1) + ']/td[2]/div[1]/div[1]').click()
                                # 尝试替换成显示等待
                                WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                                    (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                        index + 1) + ']/tbody/tr[' + str(index2 + 1) + ']/td[2]/div[1]/div[1]'))).click()
                                # time.sleep(0.5)  # 需要加，否则可能会报错 ： element is not attached to the page document
                                if specialExist == 1:
                                    # driver.find_element_by_xpath(
                                    #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                    #         index + 1) + ']/tbody/tr[' + str(
                                    #         index2 + 1) + ']/td[2]/div/table/tbody/tr/td/span/input[1]').clear()
                                    # 尝试替换成显示等待
                                    WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                                        (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                            index + 1) + ']/tbody/tr[' + str(
                                            index2 + 1) + ']/td[2]/div/table/tbody/tr/td/span/input[1]'))).clear()
                                else:
                                    # driver.find_element_by_xpath(
                                    #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                    #         index + 1) + ']/tbody/tr[' + str(
                                    #         index2 + 1) + ']/td[2]/div/table/tbody/tr/td/div').clear()
                                    # 尝试替换成显示等待
                                    WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                                        (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                            index + 1) + ']/tbody/tr[' + str(
                                            index2 + 1) + ']/td[2]/div/table/tbody/tr/td/div'))).clear()
                                # driver.find_element_by_xpath(
                                #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                #         index + 1) + ']/tbody/tr[' + str(index2 + 1) + ']/td[2]/div[1]/div[1]').click()
                                # 尝试替换成显示等待
                                WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                                    (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                        index + 1) + ']/tbody/tr[' + str(index2 + 1) + ']/td[2]/div[1]/div[1]'))).click()
                                # time.sleep(0.5)  # 需要加，否则可能会报错 ： element is not attached to the page document
                                if specialExist == 1:
                                    driver.find_element_by_xpath(
                                        '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                            index + 1) + ']/tbody/tr[' + str(
                                            index2 + 1) + ']/td[2]/div/table/tbody/tr/td/span/input[1]').send_keys(
                                        str(normalNum))  # 输入结果值
                                    # 尝试替换成显示等待
                                    WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                                        (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                            index + 1) + ']/tbody/tr[' + str(
                                            index2 + 1) + ']/td[2]/div/table/tbody/tr/td/span/input[1]'))).click()
                                else:
                                    # driver.find_element_by_xpath(
                                    #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                    #         index + 1) + ']/tbody/tr[' + str(
                                    #         index2 + 1) + ']/td[2]/div/table/tbody/tr/td/div').send_keys(
                                    #     str(normalNum))  # 输入结果值
                                    # 尝试替换成显示等待
                                    WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                                        (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                            index + 1) + ']/tbody/tr[' + str(
                                            index2 + 1) + ']/td[2]/div/table/tbody/tr/td/div'))).send_keys(
                                        str(normalNum))  # 输入结果值
                            elif "<" in refValue:  # <5.20
                                splitList = refValue.split("<")  # ['', '5.20']
                                print("分离'<'出来的参考值的最高值为：" + str(splitList[1]).strip())
                                # 随机取一个正常数值
                                normalNum = int(random.uniform(0, float(splitList[1])) * 100) / 100
                                # tr.find_element_by_xpath('.//td[2]/div[1]/div[1]').send_keys(normalNum)
                                # driver.find_element_by_xpath(
                                #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                #         index + 1) + ']/tbody/tr[' + str(index2 + 1) + ']/td[2]/div[1]/div[1]').click()
                                # 尝试替换成显示等待
                                WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                                    (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                        index + 1) + ']/tbody/tr[' + str(index2 + 1) + ']/td[2]/div[1]/div[1]'))).click()
                                # time.sleep(0.5)  # 需要加，否则可能会报错 ： element is not attached to the page document
                                if specialExist == 1:
                                    # driver.find_element_by_xpath(
                                    #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                    #         index + 1) + ']/tbody/tr[' + str(
                                    #         index2 + 1) + ']/td[2]/div/table/tbody/tr/td/span/input[1]').clear()
                                    # 尝试替换成显示等待
                                    WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                                        (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                            index + 1) + ']/tbody/tr[' + str(
                                            index2 + 1) + ']/td[2]/div/table/tbody/tr/td/span/input[1]'))).clear()
                                else:
                                    # driver.find_element_by_xpath(
                                    #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                    #         index + 1) + ']/tbody/tr[' + str(
                                    #         index2 + 1) + ']/td[2]/div/table/tbody/tr/td/div').clear()
                                    # 尝试替换成显示等待
                                    WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                                        (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                            index + 1) + ']/tbody/tr[' + str(
                                            index2 + 1) + ']/td[2]/div/table/tbody/tr/td/div'))).clear()
                                # driver.find_element_by_xpath(
                                #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                #         index + 1) + ']/tbody/tr[' + str(index2 + 1) + ']/td[2]/div[1]/div[1]').click()
                                # 尝试替换成显示等待
                                WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                                    (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                        index + 1) + ']/tbody/tr[' + str(index2 + 1) + ']/td[2]/div[1]/div[1]'))).click()
                                # time.sleep(0.5)  # 需要加，否则可能会报错 ： element is not attached to the page document
                                if specialExist == 1:
                                    # driver.find_element_by_xpath(
                                    #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                    #         index + 1) + ']/tbody/tr[' + str(
                                    #         index2 + 1) + ']/td[2]/div/table/tbody/tr/td/span/input[1]').send_keys(
                                    #     str(normalNum))  # 输入结果值
                                    # 尝试替换成显示等待
                                    WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                                        (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                            index + 1) + ']/tbody/tr[' + str(
                                            index2 + 1) + ']/td[2]/div/table/tbody/tr/td/span/input[1]'))).send_keys(
                                        str(normalNum))  # 输入结果值
                                else:
                                    # driver.find_element_by_xpath(
                                    #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                    #         index + 1) + ']/tbody/tr[' + str(
                                    #         index2 + 1) + ']/td[2]/div/table/tbody/tr/td/div').send_keys(
                                    #     str(normalNum))  # 输入结果值
                                    # 尝试替换成显示等待
                                    WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                                        (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                            index + 1) + ']/tbody/tr[' + str(
                                            index2 + 1) + ']/td[2]/div/table/tbody/tr/td/div'))).send_keys(
                                        str(normalNum))  # 输入结果值
                            elif ">" in refValue:  # >5.20  优化点：不知道上限是多少，暂时定个+1 例如 <6.20
                                splitList = refValue.split(">")  # ['5.20', '6.20']
                                print("分离'>'出来的参考值的最高值为：" + str(splitList[1]).strip())
                                # 随机取一个正常数值
                                normalNum = int(
                                    random.uniform(float(splitList[1]), float(splitList[1] + 1)) * 100) / 100
                                # driver.find_element_by_xpath(
                                #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                #         index + 1) + ']/tbody/tr[' + str(index2 + 1) + ']/td[2]/div[1]/div[1]').click()
                                # 尝试替换成显示等待
                                WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                                    (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                        index + 1) + ']/tbody/tr[' + str(index2 + 1) + ']/td[2]/div[1]/div[1]'))).click()
                                # time.sleep(0.5)  # 需要加，否则可能会报错 ： element is not attached to the page document
                                if specialExist == 1:
                                    # driver.find_element_by_xpath(
                                    #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                    #         index + 1) + ']/tbody/tr[' + str(
                                    #         index2 + 1) + ']/td[2]/div/table/tbody/tr/td/span/input[1]').clear()
                                    # 尝试替换成显示等待
                                    WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                                        (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                            index + 1) + ']/tbody/tr[' + str(
                                            index2 + 1) + ']/td[2]/div/table/tbody/tr/td/span/input[1]'))).clear()
                                else:
                                    # driver.find_element_by_xpath(
                                    #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                    #         index + 1) + ']/tbody/tr[' + str(
                                    #         index2 + 1) + ']/td[2]/div/table/tbody/tr/td/div').clear()
                                    # 尝试替换成显示等待
                                    WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                                        (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                            index + 1) + ']/tbody/tr[' + str(
                                            index2 + 1) + ']/td[2]/div/table/tbody/tr/td/div'))).clear()
                                # driver.find_element_by_xpath(
                                #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                #         index + 1) + ']/tbody/tr[' + str(index2 + 1) + ']/td[2]/div[1]/div[1]').click()
                                # 尝试替换成显示等待
                                WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                                    (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                        index + 1) + ']/tbody/tr[' + str(index2 + 1) + ']/td[2]/div[1]/div[1]'))).click()
                                # time.sleep(0.5)  # 需要加，否则可能会报错 ： element is not attached to the page document
                                if specialExist == 1:
                                    # driver.find_element_by_xpath(
                                    #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                    #         index + 1) + ']/tbody/tr[' + str(
                                    #         index2 + 1) + ']/td[2]/div/table/tbody/tr/td/span/input[1]').send_keys(
                                    #     str(normalNum))  # 输入结果值
                                    # 尝试替换成显示等待
                                    WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                                        (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                            index + 1) + ']/tbody/tr[' + str(
                                            index2 + 1) + ']/td[2]/div/table/tbody/tr/td/span/input[1]'))).send_keys(
                                        str(normalNum))  # 输入结果值
                                else:
                                    # driver.find_element_by_xpath(
                                    #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                    #         index + 1) + ']/tbody/tr[' + str(
                                    #         index2 + 1) + ']/td[2]/div/table/tbody/tr/td/div').send_keys(
                                    #     str(normalNum))  # 输入结果值
                                    # 尝试替换成显示等待
                                    WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                                        (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                            index + 1) + ']/tbody/tr[' + str(
                                            index2 + 1) + ']/td[2]/div/table/tbody/tr/td/div'))).send_keys(
                                        str(normalNum))  # 输入结果值
                            else:  # 其他特殊的参考值，例如 ++－++++  ,暂定为 未检
                                # tr.find_element_by_xpath('.//td[2]/div[1]/div[1]').send_keys("未检")
                                # driver.find_element_by_xpath(
                                #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                #         index + 1) + ']/tbody/tr[' + str(index2 + 1) + ']/td[2]/div[1]/div[1]').click()
                                # 尝试替换成显示等待
                                WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                                    (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                        index + 1) + ']/tbody/tr[' + str(index2 + 1) + ']/td[2]/div[1]/div[1]'))).click()
                                # time.sleep(0.5)  # 需要加，否则可能会报错 ： element is not attached to the page document
                                # 点击之后元素格式发生变化
                                if specialExist == 1:
                                    # driver.find_element_by_xpath(
                                    #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                    #         index + 1) + ']/tbody/tr[' + str(
                                    #         index2 + 1) + ']/td[2]/div/table/tbody/tr/td/span/input[1]').clear()
                                    # 尝试替换成显示等待
                                    WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                                        (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                            index + 1) + ']/tbody/tr[' + str(
                                            index2 + 1) + ']/td[2]/div/table/tbody/tr/td/span/input[1]'))).clear()
                                else:
                                    # driver.find_element_by_xpath(
                                    #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                    #         index + 1) + ']/tbody/tr[' + str(
                                    #         index2 + 1) + ']/td[2]/div/table/tbody/tr/td/div').clear()
                                    # 尝试替换成显示等待
                                    WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                                        (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                            index + 1) + ']/tbody/tr[' + str(
                                            index2 + 1) + ']/td[2]/div/table/tbody/tr/td/div'))).clear()
                                # driver.find_element_by_xpath(
                                #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                #         index + 1) + ']/tbody/tr[' + str(index2 + 1) + ']/td[2]/div[1]/div[1]').click()
                                # 尝试替换成显示等待
                                WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                                    (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                        index + 1) + ']/tbody/tr[' + str(index2 + 1) + ']/td[2]/div[1]/div[1]'))).click()
                                # time.sleep(0.5)  # 需要加，否则可能会报错 ： element is not attached to the page document
                                if specialExist == 1:
                                    # driver.find_element_by_xpath(
                                    #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                    #         index + 1) + ']/tbody/tr[' + str(
                                    #         index2 + 1) + ']/td[2]/div/table/tbody/tr/td/span/input[1]').send_keys(
                                    #     str("未检"))  # 输入结果值
                                    # 尝试替换成显示等待
                                    WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                                        (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                            index + 1) + ']/tbody/tr[' + str(
                                            index2 + 1) + ']/td[2]/div/table/tbody/tr/td/span/input[1]'))).send_keys(
                                        str("未检"))  # 输入结果值
                                else:
                                    # driver.find_element_by_xpath(
                                    #     '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                    #         index + 1) + ']/tbody/tr[' + str(
                                    #         index2 + 1) + ']/td[2]/div/table/tbody/tr/td/div').send_keys(
                                    #     str("未检"))  # 输入结果值
                                    # 尝试替换成显示等待
                                    WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                                        (By.XPATH, '//*[@id="divTarget"]/div/div/div[2]/div[2]/div[2]/table[' + str(
                                            index + 1) + ']/tbody/tr[' + str(
                                            index2 + 1) + ']/td[2]/div/table/tbody/tr/td/div'))).send_keys(
                                        str("未检"))  # 输入结果值
                    # 点击 科室总结 里 的"生成小结"按钮
                    driver.find_element_by_xpath('//*[@id="btnAutoSummary"]').click()
                    # time.sleep(1)  #暂时加上
                    print("开始生成【" + str(_ks) + "】的科室总结")
                    # 获取生成的小结内容，存放在小结列表里
                    # driver.find_element_by_xpath('//*[@id="btnAutoSummary"]')
                    briefSummary = driver.find_element_by_xpath('//*[@id="btnAutoSummary"]')
                    briefSummaryList[str(_ks)] = briefSummary
                    print("生成【" + str(_ks) + "】的科室总结结束")

                    # 添加诊断
                    print("开始添加诊断记录")
                    # 点击“诊断”菜单
                    # self.driver.find_element(By.CSS_SELECTOR,".tabs-narrow > li:nth-child(2) .tabs-icon").click()
                    # self.driver.find_element(By.CSS_SELECTOR,"#dgDeptDiagnosis_btnInsert .l-btn-text").click()
                    driver.execute_script("window.scrollTo(0,0)")
                    driver.find_element_by_xpath('//*[@id="tabs"]/div[1]/div[3]/ul/li[2]/a').click()
                    # 点击“新增”
                    driver.find_element_by_xpath('//*[@id="dgDeptDiagnosis_btnInsert"]').click()
                    driver.execute_script("window.scrollTo(0,0)")  #
                    # 双击第一个诊断分类下的第一个诊断
                    # 先判断是否存在第一个诊断
                    print("准备找第" + str(diagnoseIndex) + "、" + str(diagnoseIndex + 1) + "个诊断")
                    firstData = ""
                    secondData = ""
                    ifDataExist = ifElementExist(self, '//*[@id="layoutDiaSel"]/div[2]/div/div/div/div[2]/div[2]/div['
                                                       '2]/table/tbody/tr[' + str(diagnoseIndex) + ']')
                    if ifDataExist:
                        print("新增诊断的弹窗中存在第"+str(diagnoseIndex)+"条数据，即将双击数据")
                        time.sleep(1)  # 不加可能会报错 element is not attached to the page document
                        firstData = driver.find_element_by_xpath('//*[@id="layoutDiaSel"]/div['
                                                                 '2]/div/div/div/div[2]/div[2]/div['
                                                                 '2]/table/tbody/tr[' + str(diagnoseIndex) + ']')

                        # 双击第一条
                        actions = ActionChains(driver)
                        actions.double_click(firstData).perform()
                        # 再判断是否存在第二个诊断
                        ifData2Exist = ifElementExist(self,
                                                      '//*[@id="layoutDiaSel"]/div[2]/div/div/div/div[2]/div[2]/div[2]/table/tbody/tr[' + str(
                                                          diagnoseIndex + 1) + ']')
                        if ifData2Exist:
                            print("新增诊断的弹窗中存在第"+str(diagnoseIndex+1)+"条数据，即将双击数据")
                            secondData = driver.find_element_by_xpath(
                                '//*[@id="layoutDiaSel"]/div[2]/div/div/div/div[2]/div[2]/div[2]/table/tbody/tr[' + str(
                                    diagnoseIndex + 1) + ']')
                            # 双击第二条
                            actions = ActionChains(driver)
                            time.sleep(0.5)  # 不加可能会报错 element is not attached to the page document
                            actions.double_click(secondData).perform()
                    # 点击确定按钮， 新增诊断
                    driver.find_element(By.CSS_SELECTOR, "#btnDiaSel > .l-btn-left").click()
                    # 数据输入完成之后，点击保存，准备去“已检”界面收集新的科室小结
                    driver.find_element(By.CSS_SELECTOR, "#btnSave .l-btn-text").click()
                    # 弹出弹窗，提示“是否要重新生成小结”，点击“确定”
                    # driver.find_element(By.CSS_SELECTOR, ".l-btn-focus .l-btn-text").click()
                    # 尝试显示等待
                    WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                      (By.CSS_SELECTOR, '.l-btn-focus .l-btn-text'))).click()

                    # 进入“已检”
                    print("准备进入已检界面")
                    print("加载中...")
                    driver.find_element_by_xpath('//*[@id="formSearch"]/div[18]/div/label[3]/input').click()
                    time.sleep(0.5) #需要，否则可能会出现加载未完成的情况
                    # 找到新生成的科室小结
                    # 先点击对应的检查编号,逻辑跟上面的代码相同
                    dataList = driver.find_elements_by_xpath(
                        '//*[@id="layoutPersonList"]/div[2]/div/div/div/div[2]/div[2]/div[2]/table/tbody/tr')
                    # 强制等五秒好像太慢了，不等待的话会报错  element is not attached to the page document
                    # 优化点：改为显示等待元素加入到dom之后，再下一步操作 （用presence_of_element_located无效），改用显示等待+EC判断是否可点击
                    # time.sleep(5)
                    # 科室检查——遍历搜索出来的一行行数据，找出刚刚登记的那条
                    for index, data in enumerate(dataList):
                        # 很好的显示等待方法 ↓
                        # WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                        #   (By.XPATH, '//*[@id="layoutPersonList"]/div[2]/div/div/div/div[2]/div[2]/div[2]/table/tbody')))
                        # WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
                        #     (By.XPATH, '//*[@id="layoutPersonList"]/div[2]/div/div/div/div[2]/div[2]/div[2]/table/tbody/tr')))
                        # element_to_be_clickable
                        # 从搜索结果中找刚刚登记的那条
                        for _ in range(3):
                            try:
                                WebDriverWait(driver, 10).until(
                                    EC.visibility_of_element_located((By.XPATH,
                                                                      '//*[@id="layoutPersonList"]/div[2]/div/div/div/div[2]/div[2]/div[2]/table/tbody/tr'))
                                )
                            except Exception:
                                time.sleep(1)
                                print("再等一秒看看能不能找到结果")
                        # 【报错】 ：element is not attached to the page document，修改方案：data改为driver
                        time.sleep(1)  # 不加可能会报错 ↑
                        # ksCheckNo = data.find_element_by_xpath('.//td[4]/div[1]').text  # 科室检查通过查询查出来的检查编号
                        ksCheckNo = driver.find_element_by_xpath(
                            '//*[@id="layoutPersonList"]/div[2]/div/div/div/div[2]/div[2]/div[2]/table/tbody/tr[' + str(
                                index + 1) + ']/td[4]/div[1]').text  # 科室检查通过查询查出来的检查编号
                        # print("搜索的检查编号是有"+str(ksCheckNo))
                        print("正在遍历的检查编号是：" + str(ksCheckNo))
                        if checkNo == ksCheckNo:  # 查找刚刚登记的用户对应检查编号的数据行
                            # print("找到了")
                            # 【报错】 ：element is not attached to the page document，修改方案：data改为driver
                            # data.find_element_by_xpath('.//td[4]/div[1]').click()
                            # 点击刚刚登记的体检数据
                            driver.find_element_by_xpath(
                                '//*[@id="layoutPersonList"]/div[2]/div/div/div/div[2]/div[2]/div[2]/table/tbody/tr[' + str(
                                    index + 1) + ']/td[4]/div[1]').click()
                            # 获取新的科室总结内容
                            print("开始收集科室总结内容")
                            newBreifSummary = driver.find_element_by_xpath(
                                '//*[@id="_easyui_textbox_input6"]').get_attribute("value")
                            print("获取新的科室总结内容：" + newBreifSummary)
                            print("开始收集诊断内容")
                            # 点击 “诊断”
                            driver.find_element_by_xpath('//*[@id="tabs"]/div[1]/div[3]/ul/li[2]/a').click()
                            common = '//*[@id="tabs"]/div[2]/div[2]/div/div/div/div[2]/div[2]/div[2]/table/tbody'
                            kszdList = driver.find_elements_by_xpath(common + '/tr')
                            for index, kszd in enumerate(kszdList):
                                zdDict = {} # 诊断信息
                                zdName = driver.find_element_by_xpath(
                                    common + '/tr[' + str(index + 1) + ']/td[5]/div/div').text
                                zdDesc = driver.find_element_by_xpath(
                                    common + '/tr[' + str(index + 1) + ']/td[4]/div').text
                                zdType = driver.find_element_by_xpath(
                                    common + '/tr[' + str(index + 1) + ']/td[6]/div').text
                                zdIcd = driver.find_element_by_xpath(
                                    common + '/tr[' + str(index + 1) + ']/td[7]/div').text
                                zdAdvice = driver.find_element_by_xpath(
                                    common + '/tr[' + str(index + 1) + ']/td[8]/div/div').text
                                zdDict["zdName"] = zdName
                                zdDict["zdDesc"] = zdDesc
                                zdDict["zdType"] = zdType
                                zdDict["zdIcd"] = zdIcd
                                zdDict["zdAdvice"] = zdAdvice
                                zdAllList.append(zdDict)
                                print("目前收集到的诊断信息为："+str(zdAllList))

                            # 更新列表里的科室小结内容
                            briefSummaryList[str(_ks)] = newBreifSummary

                            break
                    print("添加诊断记录结束")
                    diagnoseIndex = diagnoseIndex * 2 + 1
                    break  # 找到了刚刚登记的体检数据行之后，操作完之后就不用继续往下找了
        print("收集到的所有科室（目前是两个科室）的科室小结为：" + str(briefSummaryList))
        print("收集到的所有科室（目前是两个科室）的诊断信息为：" + str(zdAllList))
        print("结束科室检查")
        print("开始医生总检")
        # 点击医生总检界面
        # 切换到主iframe
        driver.switch_to.default_content()
        for _ in range(3):
            try:
                WebDriverWait(driver, 10).until(
                    EC.element_to_be_clickable((By.XPATH, '//div[@id="_easyui_tree_14"]/span[3]'))
                )
            except Exception:
                time.sleep(1)
                print("再等一秒看看能不能点击医生总检")
        assert driver.find_element(By.XPATH, '//*[@id="_easyui_tree_14"]/span[3]').text == "医生总检"  # 如果点击的不是科室检查就报错
        driver.find_element(By.XPATH, '//*[@id="_easyui_tree_14"]/span[3]').click()
        driver.switch_to.frame(3)
        # 选择日期范围：今天
        # driver.find_element(By.CSS_SELECTOR, ".datebox:nth-child(4) .textbox-icon").click()
        time.sleep(1)
        WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
              (By.XPATH, '//*[@id="formSearch"]/div[1]/span[2]/span/a'))).click()
        driver.find_element(By.LINK_TEXT, "今天").click()
        # 点击搜索
        driver.find_element(By.CSS_SELECTOR, "#btnSearch .l-btn-text").click()
        # 然后找当前人员
        dataList = driver.find_elements_by_xpath(
            '//*[@id="layoutPersonList"]/div[2]/div/div/div/div[2]/div[2]/div[2]/table/tbody/tr')
        # 强制等五秒好像太慢了，不等待的话会报错  element is not attached to the page document
        # 优化点：改为显示等待元素加入到dom之后，再下一步操作 （用presence_of_element_located无效），改用显示等待+EC判断是否可点击
        # time.sleep(5)
        # 科室检查——遍历搜索出来的一行行数据，找出刚刚登记的那条
        for index, data in enumerate(dataList):
            # 很好的显示等待方法 ↓
            # WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
            #   (By.XPATH, '//*[@id="layoutPersonList"]/div[2]/div/div/div/div[2]/div[2]/div[2]/table/tbody')))
            # WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
            #     (By.XPATH, '//*[@id="layoutPersonList"]/div[2]/div/div/div/div[2]/div[2]/div[2]/table/tbody/tr')))
            # element_to_be_clickable
            # 从搜索结果中找刚刚登记的那条
            for _ in range(3):
                try:
                    WebDriverWait(driver, 10).until(
                        EC.visibility_of_element_located((By.XPATH,
                                                          '//*[@id="layoutPersonList"]/div[2]/div/div/div/div[2]/div[2]/div[2]/table/tbody/tr'))
                    )
                except Exception:
                    time.sleep(1)
                    print("再等一秒看看能不能找到结果")
            # 【报错】 ：element is not attached to the page document，修改方案：data改为driver
            time.sleep(2)  # 不加可能会报错 ↑，1秒仍然会报错
            # ksCheckNo = data.find_element_by_xpath('.//td[4]/div[1]').text  # 科室检查通过查询查出来的检查编号
            ksCheckNo = driver.find_element_by_xpath(
                '//*[@id="layoutPersonList"]/div[2]/div/div/div/div[2]/div[2]/div[2]/table/tbody/tr[' + str(
                    index + 1) + ']/td[4]/div[1]').text  # 科室检查通过查询查出来的检查编号
            print("正在遍历的检查编号是：" + str(ksCheckNo))
            if checkNo == ksCheckNo:  # 查找刚刚登记的用户对应检查编号的数据行
                print("找到了")
                # 【报错】 ：element is not attached to the page document，修改方案：data改为driver
                # data.find_element_by_xpath('.//td[4]/div[1]').click()
                # 点击刚刚登记的体检数据
                driver.find_element_by_xpath(
                    '//*[@id="layoutPersonList"]/div[2]/div/div/div/div[2]/div[2]/div[2]/table/tbody/tr[' + str(
                        index + 1) + ']/td[4]/div[1]').click()
                print("开始总检")
                # 点击“记录”按钮，开始总检
                print("点击记录按钮")
                driver.find_element(By.CSS_SELECTOR, "#btnEdit .l-btn-text").click()
                time.sleep(0.5)
                print("点击保存按钮")
                driver.find_element(By.XPATH, '//*[@id="btnSave"]').click()
                break
        print("进入已总模块")
        driver.find_element(By.XPATH, '//*[@id="formSearch"]/div[18]/div/label[4]/input').click()
        time.sleep(1)  #等待已总的数据加载完成
        # 然后找当前人员
        dataList = driver.find_elements_by_xpath(
            '//*[@id="layoutPersonList"]/div[2]/div/div/div/div[2]/div[2]/div[2]/table/tbody/tr')
        # 强制等五秒好像太慢了，不等待的话会报错  element is not attached to the page document
        # 优化点：改为显示等待元素加入到dom之后，再下一步操作 （用presence_of_element_located无效），改用显示等待+EC判断是否可点击
        # time.sleep(5)
        # 科室检查——遍历搜索出来的一行行数据，找出刚刚登记的那条
        for index, data in enumerate(dataList):
            # 很好的显示等待方法 ↓
            # WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
            #   (By.XPATH, '//*[@id="layoutPersonList"]/div[2]/div/div/div/div[2]/div[2]/div[2]/table/tbody')))
            # WebDriverWait(driver, 10).until(EC.element_to_be_clickable(
            #     (By.XPATH, '//*[@id="layoutPersonList"]/div[2]/div/div/div/div[2]/div[2]/div[2]/table/tbody/tr')))
            # element_to_be_clickable
            # 从搜索结果中找刚刚登记的那条
            for _ in range(3):
                try:
                    WebDriverWait(driver, 10).until(
                        EC.visibility_of_element_located((By.XPATH,
                                                          '//*[@id="layoutPersonList"]/div[2]/div/div/div/div[2]/div[2]/div[2]/table/tbody/tr'))
                    )
                except Exception:
                    time.sleep(1)
                    print("再等一秒看看能不能找到结果")
            # 【报错】 ：element is not attached to the page document，修改方案：data改为driver
            time.sleep(1)  # 不加可能会报错 ↑
            # ksCheckNo = data.find_element_by_xpath('.//td[4]/div[1]').text  # 科室检查通过查询查出来的检查编号
            ksCheckNo = driver.find_element_by_xpath(
                '//*[@id="layoutPersonList"]/div[2]/div/div/div/div[2]/div[2]/div[2]/table/tbody/tr[' + str(
                    index + 1) + ']/td[4]/div[1]').text  # 科室检查通过查询查出来的检查编号
            print("正在遍历的检查编号是：" + str(ksCheckNo))
            if checkNo == ksCheckNo:  # 查找刚刚登记的用户对应检查编号的数据行
                print("找到了")
                # 【报错】 ：element is not attached to the page document，修改方案：data改为driver
                # data.find_element_by_xpath('.//td[4]/div[1]').click()
                # 点击刚刚登记的体检数据
                driver.find_element_by_xpath(
                    '//*[@id="layoutPersonList"]/div[2]/div/div/div/div[2]/div[2]/div[2]/table/tbody/tr[' + str(
                        index + 1) + ']/td[4]/div[1]').click()
                print("开始验证各项信息")
                # 进入“个人信息模块”
                print("进入个人信息模块")
                driver.find_element_by_xpath('//*[@id="divInfoTabs"]/div[1]/div[3]/ul/li[2]/a').click()
                print("开始核对人员基本信息...")
                personName=driver.find_element_by_xpath('//*[@id="formPersonInfo"]/div[1]/div[1]').text #名称
                personSex=driver.find_element_by_xpath('//*[@id="formPersonInfo"]/div[1]/div[2]').text #性别
                personAge=driver.find_element_by_xpath('//*[@id="formPersonInfo"]/div[1]/div[3]').text  #年龄
                personMarried=driver.find_element_by_xpath('//*[@id="formPersonInfo"]/div[1]/div[4]').text #婚姻
                personCheckNo=driver.find_element_by_xpath('//*[@id="formPersonInfo"]/div[3]/div').text #检查编号
                personCompany=driver.find_element_by_xpath('//*[@id="formPersonInfo"]/div[6]/div').text #单位
                personDept=driver.find_element_by_xpath('//*[@id="formPersonInfo"]/div[7]/div').text #部门
                personType=driver.find_element_by_xpath('//*[@id="formPersonInfo"]/div[8]/div').text  #体检类型
                personPackage=driver.find_element_by_xpath('//*[@id="formPersonInfo"]/div[9]/div').text #套餐名称
                assert data_person['姓名'] ==  personName
                assert data_person['性别'] ==  personSex
                assert data_person['年龄']+"岁" ==  personAge
                assert data_person['婚姻'] ==  personMarried
                assert checkNo ==  personCheckNo
                assert data_person['单位'] ==  personCompany
                assert data_person['部门'] ==  personDept
                assert data_person['体检类型'] ==  personType
                assert data_person['套餐名称'] ==  personPackage

                print("【人员基本信息正确】")
                print("开始核对检查项目列表...")
                # 验证检查项目列表是否与登记的相同  cp=checkProject="检查项目"
                cpList = driver.find_elements_by_xpath(
                    '//*[@id="divInfoTabs"]/div[2]/div[2]/div/div/div[2]/div/div/div/div[2]/div[2]/div[2]/table/tbody/tr')
                cpNameList = []
                for index, cp in enumerate(cpList):
                    cpName = driver.find_element_by_xpath(
                        '//*[@id="divInfoTabs"]/div[2]/div[2]/div/div/div[2]/div/div/div/div[2]/div[2]/div[2]/table/tbody/tr[' + str(
                            index + 1) + ']/td/div').text
                    # print("名为：" + cpName)
                    if '无' in cpName :
                        cpName=cpName.replace('\n', '').replace('\r', '')  # 去掉空格和换行符
                        cpName=cpName[0:len(cpName)-1]
                        # print("新名为："+cpName)
                    cpNameList.append(cpName)
                # print("总的为：" + str(cpNameList))
                assert checkProjectNameList == cpNameList
                print("【“检查项目列表”信息正确】")
                print("开始核对科室小结...")
                # 验证 科室小结是否与科室检查时描述的相同
                # 点击“科室小结” 菜单
                driver.find_element_by_xpath('//*[@id="divRegion-1"]/div/div[1]/div[3]/ul/li[2]/a').click()
                # 科室列表
                common = '//*[@id="divRegion-1"]/div/div[2]/div[2]/div/div/div/div[2]/div[2]/div[2]/table/tbody'
                ksxjList = driver.find_elements_by_xpath(common + '/tr')
                for index, ksxj in enumerate(ksxjList):
                    # 科室名
                    ksxjName = driver.find_element_by_xpath(common + '/tr[' + str(index + 1) + ']/td[2]/div').text
                    # 科室小结
                    ksxjResult = driver.find_element_by_xpath(common + '/tr[' + str(index + 1) + ']/td[3]/div/div').text
                    # 遍历每个做过检查的科室对应的科室小结
                    for k, v in briefSummaryList.items():
                        if k == ksxjName:
                            assert v == ksxjResult  # 判断小结内容是否相同
                        else:
                            pass
                            # assert ksxjResult == '未检。'  #未做检查，且科室中有指标的科室默认显示“未检。”，无指标的默认显示“未见异常”
                print("【科室小结信息正确】")
                print("开始核对综述...")
                zs = driver.find_element_by_xpath('//*[@id="_easyui_textbox_input12"]').get_attribute("value").replace('\n', '').replace('\r', '')  # 去掉空格和换行符
                print("综述为："+zs)
                for k, v in briefSummaryList.items():
                    x = "[" + k + "]" + v
                    print("应该存在的综述为：" + x)
                    if k in zs:
                        assert x in zs  # 如果 “耳鼻咽喉科” 在综述里 并且 “[耳鼻咽喉科]未检。” 在综述里 ，就能证明存在且正确
                print("【综述信息正确】")
                print("开始核对诊断...")
                # 点击“诊断”菜单
                driver.find_element_by_xpath('//*[@id="divRegion-2"]/div/div[1]/div[3]/ul/li[2]/a').click()
                zdList = driver.find_elements_by_xpath(
                    '//*[@id="divRegion-2"]/div/div[2]/div[2]/div/div/div/div[2]/div[2]/div[2]/table')
                for index, i in enumerate(zdAllList):  # 遍历科室检查过程中收集到的诊断信息
                    # for k, v in i.items():  # 每条信息都是字典形式的
                    #     ifExist = 0
                        for index, zd in enumerate(zdList): # 遍历医生总检界面里的诊断信息
                            # ifExist = 0  # 初始化：因为一条记录核对正确后ifExist=1,需要初始化为0，然后继续找下一条
                            common = '//*[@id="divRegion-2"]/div/div[2]/div[2]/div/div/div/div[2]/div[2]/div[2]/table/tbody'
                            # 诊断名称
                            zdName = driver.find_element_by_xpath(common + '/tr[' + str(index + 1) + ']/td[5]/div/div').text
                            # 描述
                            zdDesc = driver.find_element_by_xpath(common + '/tr[' + str(index + 1) + ']/td[4]/div').text
                            # 分类
                            zdType = driver.find_element_by_xpath(common + '/tr[' + str(index + 1) + ']/td[6]/div').text
                            # ICD
                            zdIcd = driver.find_element_by_xpath(common + '/tr[' + str(index + 1) + ']/td[7]/div').text
                            # 处理意见
                            zdAdvice = driver.find_element_by_xpath(common + '/tr[' + str(index + 1) + ']/td[8]/div/div').text
                            if i.get("zdName") == zdName:
                                assert i.get("zdDesc") == zdDesc
                                assert i.get("zdType") == zdType
                                assert i.get("zdIcd") == zdIcd
                                assert i.get("zdAdvice") == zdAdvice
                                # ifExist = 1
                                break
                        # assert ifExist == 1  #如果不为1，说明科室诊断中收集的诊断信息未在医生总检的诊断中出现


                print("【诊断信息正确】")
                print("核对各项信息结束")
                print("结束总检")

        print("结束医生总检")
